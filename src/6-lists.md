# 列表

学习了第6课,你将能够:

- 理解构成列表的元素
- 学习构建列表
- 理解函数式编程中列表的角色
- 使用常见的列表函数
- 学习惰性求值的基础

从很多方面来说，数组都是C语言编程的基本数据结构。如果你正确理解了C语言中的数组，你就必须理解内存分配是如何工作的，数据如何存储在计算机上，以及指针和指针算术的基础知识。Haskell(和一般的函数式编程)的基本数据结构是列表。即使你在本书中学习一些更高级的主题，如functor和monad，简单的列表仍然是最有用的例子。这一课将适当地介绍这个非常重要的数据结构。你将学习将列表拆分和合并的基础知识，以及Haskell提供的列表的一些基本函数。最后，介绍Haskell的另一个独特特性:惰性求值。惰性求值非常强大，它允许你表示和处理无限长的列表!当你在Haskell中遇到某个问题时，回头看看列表是否能给你一些启发，这几乎总是用得上。


>**考虑这个** 你为一家有10,000名员工的公司工作，其中一些人想在下班后参加垒球队。该公司有五个以颜色命名的团队，你希望将员工分配到这些队伍:
> ```haskell
> teams = ["red","yellow","orange","blue","purple"]
> ```
> 您有一个员工列表，您希望将他们均匀地匹配到正确的团队.有没有一种简单的方法使用Haskell列表函数完成这个任务吗?

## 列表的结构

列表是函数式编程中最重要的数据结构。其中一个关键原因是列表本身就是递归的。列表要么是一个空列表，要么是一个元素后面跟着另一个列表。分解和构建列表是函数式编程中许多技术的基本工具。

在分解列表时，主要方法是是头(`head`)、余下(`tail`)和尾(用`[]`表示)。`head`只是列表中的第一个元素:

```
GHCi> head [1,2,3]
1
GHCi> head [[1,2],[3,4],[5,6]]
[1,2]
```
`tail`只是代表列表在头之后余下的元素:
```
GHCi> tail [1,2,3]
[2,3]
GHCi> tail [3]
[]
```

只有一个元素的列表的尾部是`[]`，表示列表结束。列表的末尾只是一个空列表。但空列表不同于其他列表，因为它既没有头也没有尾。在`[]`上调用`head`或`tail`将导致错误。看一下表头和表尾，就会发现列表的递归性质:表头是一个元素，表尾是另一个列表。可以把这一过程可视化。

![](pic/6-1-list.jpg)

你可以把列表拆成小块，但如果你不能再把它们拼起来，这也没什么用!在函数式编程中，建立列表和分解列表一样重要。要构建一个列表，只需要一个函数`cons`和作为同义词的中缀运算符`(:)`。这个术语是construct的缩写，起源于Lisp。我们把这个操作称为consing，因为`:`在句子中看起来有点奇怪。

要创建列表，需要将一个值与另一个列表进行连接。创建列表的最简单方法是使用空列表构造一个值:

```
GHCi> 1:[]
[1]
```
在底层，Haskell中的所有列表都实现为系列consing操作，而`[...]`表示法不过是一种语法糖(编程语言语法的一种特性，旨在使代码更易于阅读):

```
GHCi> 1:2:3:4:[]
[1,2,3,4]
GHCi> (1,2):(3,4):(5,6):[]
[(1,2),(3,4),(5,6)]
```

注意，所有这些列表都以空列表`[]`结尾。根据定义，列表总是一个值与另一个列表(也可以是空列表)合并。如果愿意，可以把一个值添加到现有列表的前面:

```
GHCi> 1:[2,3,4]
[1,2,3,4]
```
值得注意的是，到目前为止你看到的字符串本身都是字符列表的语法糖(单个字符用单引号而不是双引号表示):

```
GHCi>['h','e','l','l','o']
"hello"
GHCi> 'h':'e':'l':'l':'o':[]
"hello"
```
注意注意注意，在Haskell中，列表中的每个元素必须是相同的类型。例如，你可以将字母`'h'`与字符串`"ello"`拼接起来，因为`"ello"`只是一个字符列表，而`'h'`(单引号)是一个字符:

```
GHCi> 'h':"ello"
"hello"
```
但你不能将`"h"`(双引号)拼接到`"ello"`，因为`"h"`是一个字符列表，而`"ello"`中的**值**是单个字符。当你移除语法糖时，这就更加明显。

```haskell
"h":"ello" -- 错误!
['h']:['e','l','l','o']   -- 移除一层语法糖
'h':[]:'e':'l':'l':'o':[] -- 完全移除语法糖
```
如果你确实想合并两个列表，则需要使用`++`将它们连接起来。你在第3课中见过拼接文本，但鉴于字符串就是列表，`++`其实适用于任何列表:

```
GHCi> "h" ++ "ello"
"hello"
GHCi> [1] ++ [2,3,4]
[1,2,3,4]
```

列表的拼接和拆分在为列表编写递归函数时有根本性的重大作用。函数式编程中几乎所有的顺序操作都涉及构建列表、分解列表或二者结合。

## 列表与惰性求值

因为列表在Haskell中非常重要，所以有很多方法可以快速生成数据范围。下面是一些例子:

Because lists are so important in Haskell, there are many ways to quickly generate ranges of data. Here are some examples

```haskell
[1 .. 10] -- 从1到10的一系列值构成的列表 
[1,2,3,4,5,6,7,8,9,10]

[1,3 .. 10] -- 下一个值是3,即创建奇数
[1,3,5,7,9]

[1, 1.5 .. 5] -- 下一个值是1.5,即步长为0.5
[1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0] -- 注意元素的类型是 Double

[1,0 .. -10] -- 降序列表
[1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
```

有用的，但不特别出彩。许多编程语言都有以类似方式工作的`range`函数。可是,如果你忘了给值域设定上界会怎样?

```
GHCi> [1 .. ]
[1,2,3,4,5,6,7,8,9,10,11,12 ..
```

生成一个无尽列表!这很酷，但很快就会阻塞终端，似乎不是特别有用。有趣的是，你可以将这个列表赋值给一个变量，甚至在函数中使用它:

```haskell
simple x = x
longList = [1 .. ]
stillLongList = simple longList
```
令人震惊的是，这段代码正常通过编译了。你定义了一个无限列表，然后在函数中使用它。为什么Haskell没有在计算无限长的列表时绷住?**因为它没有完全求出这个列表**.Haskell使用一种特殊形式的求值，称为**惰性求值**。在惰性求值中，除非需要，否则不会对代码求值。在使用longList的情况下，不需要计算列表中的任何值。

惰性求值既有优点，也有缺点。很容易看出其中的一些优点。首先，计算上的好处是，任何不是绝对需要的代码都不会被计算。另一个好处是，你可以定义和使用有趣的结构，如无限列表。这对于很多实际问题都很有用。惰性求值的缺点不那么明显。最大的问题是很难推断代码的性能。在这个简单的例子中，很容易看出传递给`simple`的任何参数都不会被求值，但稍微复杂一点，这一点就不那么明显了。更大的问题是，你可以很容易成谱系地构建大量的未求值函数，而将这些函数的结果算出来,存储其结果比存储这一系列 _待求值代码(thunk)_ 成本要低得多。

> 小测: 判断, 你是否能编译运行一段程序,其中变量`backwardsInfinity = reverse [1..]`.
> <details><summary>答案</summary>
> 行. 即使你想翻转一个没有头的列表,如果你没有用到它,它就不会被求值.可是,如果你打开GHCi然后输入
> 
>  <code><pre>GHCi> backwardsInfinity</pre></code>
> 
> 那么你触动了对其的求值,这个求值过程就没有尽头了.
> </details>

## 常用列表函数

由于列表非常重要，Haskell的标准库模块Prelude中内置了大量常用的函数。到目前为止，我们已经见过`head`、`tail`、`:`和`++`，它们允许你将列表拆开并重新组合在一起。在编写Haskell时，还有许多列表函数会频繁出现，因此值得您掌握。

###  `!!` 运算符
如果希望通过索引访问列表中的特定元素，可以使用`!!`操作符。`!!`操作符接受一个列表和一个数字，返回列表中该位置的元素。Haskell中的列表从0开始索引。如果你试图访问列表末尾以外的值，就会得到一个错误:

```
GHCi> [1,2,3] !! 0
1
GHCi> "puppies" !! 4
'i'
GHCi> [1..10] !! 11
*** Exception: Prelude.!!: index too large
```

如第5课所述，任何中缀操作符(位于两个值之间的操作符，如`+`)也可以像前缀函数一样使用，只需将其包装在括号中:

```
GHCi> (!!) [1,2,3] 0
1
```

使用前缀表示法可以使诸如部分应用的事情变得更容易。前缀表示法对于使用操作符作为其他函数的参数也很有用。您仍然可以使用带有中缀运算符的部分应用表达式;你只需要把表达式用圆括号括起来:

```
GHCi> paExample1 = (!!) "dog"
GHCi> paExample1 2
'g'
GHCi> paExample2 = ("dog" !!)
GHCi> paExample2 2
'g'
```

注意，在`paExample2`中，你会看到部分应用是如何使用中缀二元运算符的。要对二元运算符(称为节)执行部分应用，需要将表达式包裹在括号中。如果只包含右边的参数，函数会等待最左边的参数;如果你只在左边包含参数，就会得到一个等待右边参数的函数。下面是`paExample3`，它创建了对右参数的部分应用:

```
GHCi> paExample3 = (!! 2)
GHCi> paExample3 "dog"
'g'
```

关于部分应用节，要记住，括号不是可选的。

### `length`

顾名思义;它给出了列表的长度!
```
GHCi> length [1..20]
20
GHCi> length [(10,20),(1,2),(15,16)]
3
GHCi> length "quicksand"
9
```

### `reverse`
`reverse` 从头到尾翻转这个列表:
```
GHCi> reverse [1,2,3]
[3,2,1]
GHCi> reverse "cheese"
"eseehc"
```
> 译注: 这就要求了,length,reverse 等等所应用的列表必须是有尽的.否则它们就不会停下.

您可以使用`reverse`来创建一个基本的回文检查器，如下面的代码所示。

```
isPalindrome word = word == reverse word
GHCi> isPalindrome "cheese"
False
GHCi> isPalindrome "racecar"
True
GHCi> isPalindrome [1,2,3]
False
GHCi> isPalindome [1,2,1]
True
```

### `elem`

`elem`函数接受一个值和一个列表，并检查该值是否在列表中:


```
GHCi> elem 13 [0,13 .. 100]
True
GHCi> elem 'p' "cheese"
False
```

为了提高可读性，您可能希望将`elem`函数视为中缀操作符。任何二元函数都可以被视为中缀运算符，只需将其括在反引号(`` ` `` )中。例如，函数`response`根据字符串是否有感叹号返回不同的响应，如下所示。

```
respond phrase = if '!' `elem` phrase
                 then "wow!"
                 else "uh.. okay"
GHCi> respond "hello"
"uh.. okay"
GHCi> respond "hello!"
"wow!"
```

中缀`elem`是否增加可读性确实是有争议的，但在现实世界中，您会经常遇到中缀形式的二元函数。


### `take` 与 `drop`

take函数接受一个数字和一个列表作为参数，然后返回列表的前n个元素:
```
GHCi> take 5 [2,4..100]
[2,4,6,8,10]
GHCi> take 3 "wonderful"
"won"
```

如果你需要比列表长度更多的值，`take`尽可能多给你一些值，即已有的整个列表，不会发生错误:

```
GHCi> take 1000000 [1]
[1]
```

`take`与列表中的其他函数结合使用效果最好。例如，您可以将`take`与`reverse`组合以获得列表的最后n个元素。

```
takeLast n aList = reverse (take n (reverse aList))
GHCi> takeLast 10 [1..100]
[91,92,93,94,95,96,97,98,99,100]
```
drop函数类似于take，不同之处在于它删除列表的前n个元素,并返回给你剩下的列表:

```
GHCi> drop 2 [1,2,3,4,5]
[3,4,5]
GHCi> drop 5 "very awesome"
"awesome"
```

###  `zip`

当您想要将两个列表组合成元组对的列表时，可以使用`zip`。`zip`的参数是两个列表。如果一个列表较长，当两个列表中有一个为空时，`zip`将停止:
```
GHCi> zip [1,2,3] [2,4,6]
[(1,2),(2,4),(3,6)]
GHCi> zip "dog" "rabbit"
[('d','r'),('o','a'),('g','b')]
GHCi> zip ['a' .. 'f'] [1 .. ]
[('a',1),('b',2),('c',3),('d',4),('e',5),('f',6)]
```

### `cycle`

`cycle`函数特别有趣，因为它使用惰性求值来创建无限列表。给定一个列表，`cycle`无限地重复这个列表。这可能看起来没什么用，但在很多情况下都很有用。例如，在数值计算中，通常需要一个包含n个1的列表。有了`cycle`，这个函数很容易实现。


```
ones n = take n (cycle [1])
GHCi> ones 2
[1,1]
GHCi> ones 4
[1,1,1,1]
```
在对列表成员进行分组时，Cycle非常有用。假设你想把一组文件分到n台服务器上，或者类似地把员工分到n个团队。一般的解决方案是创建一个新的函数assignToGroups，它接受一些组和一个列表，然后循环遍历组，为它们分配成员。

```
assignToGroups n aList = zip groups aList
    where groups = cycle [1..n]

GHCi> assignToGroups 3 ["file1.txt","file2.txt","file3.txt","file4.txt","file5.txt","file6.txt","file7.txt","file8.txt"] 

[(1,"file1.txt"),(2,"file2.txt"),(3,"file3.txt"),(1,"file4.txt"),(2,"file5.txt"),(3,"file6.txt"),(1,"file7.txt"),(2,"file8.txt")]

GHCi> assignToGroups 2 ["Bob","Kathy","Sue","Joan","Jim","Mike"]
[(1,"Bob"),(2,"Kathy"),(1,"Sue"),(2,"Joan"),(1,"Jim"),(2,"Mike")]
```

这些函数只是Haskell提供的众多列表函数中比较常见的一些。并非列表上的所有函数都包含在标准的`Prelude`模块中。所有的列表函数，包括那些自动包含在`Prelude`中的，都在`Data.List`中。详尽的数据列表。[标准Haskell文档](https://hackage.haskell.org/package/basedocs/Data-List.html)可以在线查阅列表函数。

## 总结

这一课的目标是学习列表的基本结构。你学到了列表是由头和尾组成的，通过`cons`连接在一起。我们还在列表中介绍了许多最常用的函数。现在来做一下习题吧。

**Q6.1** Haskell有一个名为`repeat`的函数，它接受一个值并无限地重复该值。使用你已经学过的函数实现你自己版本的`repeat`。 


**Q6.2** 编写一个函数subseq，它接受三个参数:起始位置、结束位置和列表。该函数应该返回起始和结束之间的子序列。例如:
```
GHCi> subseq 2 5 [1 .. 10]
[3,4,5]
GHCi> subseq 2 7 "a puppy"
"puppy"
```
**Q6.3** 编写一个`inFirstHalf`函数，当元素位于列表的前半部分时返回`True`，否则返回`False`。 
